#include <WiFi.h>
#include <U8g2lib.h>
#include <Wire.h>
#include <vector>
#include <WiFiServer.h>
#include <Preferences.h>

// OLED Setup (4-pin I²C)
U8G2_SSD1306_128X64_NONAME_F_SW_I2C u8g2(
  U8G2_R0,
  /* clock=*/22,  // SCL pin
  /* data=*/21,   // SDA pin
  /* reset=*/U8X8_PIN_NONE
);

// Onboard LED
#define LED_PIN 2

// Single Button Pin
#define BTN_CYCLE 33  // Changed from 25 to 33

// ============================================================================
// BATTERY MANAGEMENT SYSTEM (NVS-Based Pseudo-Battery Meter)
// ============================================================================

// Battery Configuration
#define BATTERY_FULL_CAPACITY_MAH    2200    // Full battery capacity (mAh)
#define BATTERY_AVERAGE_CURRENT_MA   250     // Average current consumption (mA)
#define BATTERY_UPDATE_INTERVAL_MS   30000   // Update every 30 seconds
#define BATTERY_RESET_HOLD_TIME_MS   5000    // Hold button 5s to reset
#define BATTERY_CRITICAL_MAH         220     // 10% threshold
#define BATTERY_LOW_MAH              440     // 20% threshold

// Battery State Variables
Preferences batteryPrefs;
float batteryRemainingMah = BATTERY_FULL_CAPACITY_MAH;
unsigned long lastBatteryUpdate = 0;
unsigned long batteryResetPressStart = 0;
bool batteryResetButtonPressed = false;
bool lowBatteryWarningShown = false;

// WiFi
const char* ssid = "ZYNC_Device";
const char* password = "zync1234";

// TCP Server for Live Scan
WiFiServer tcpServer(8888);
WiFiClient client;
bool liveScanActive = false;
unsigned long lastLiveScan = 0;
const unsigned long liveScanInterval = 1000; // Scan every 1 second

// Scan control
unsigned long lastScan = 0;
const unsigned long scanInterval = 5000;

// Navigation state
int currentIndex = 0;
int foundNetworks = 0;

// Connection tracking
bool wasConnected = false;
unsigned long connectionMessageTime = 0;
bool showingConnectionMessage = false;
bool appConnected = false; // Track if app is connected via TCP

// Debounce
unsigned long lastButtonTime = 0;
const int debounceDelay = 200;

// WiFi scan data
struct NetworkInfo {
  String ssid;
  String bssid;
  int rssi;
  int channel;
  int frequency;
  String encryption;
};

std::vector<NetworkInfo> networks;

// Add animation variables at the top with other global variables
int scanDots = 0;
unsigned long lastDotUpdate = 0;
const int dotUpdateInterval = 300; // Update dots every 300ms

// ============================================================================
// BATTERY MANAGEMENT FUNCTIONS
// ============================================================================

void initBattery() {
  if (!batteryPrefs.begin("battery", false)) {
    Serial.println("[ERROR] Failed to initialize NVS for battery!");
    return;
  }
  
  bool isInitialized = batteryPrefs.getBool("init", false);
  
  if (!isInitialized) {
    batteryPrefs.putFloat("remaining", BATTERY_FULL_CAPACITY_MAH);
    batteryPrefs.putBool("init", true);
    Serial.println("[Battery] NVS initialized with full capacity");
  }
  
  batteryRemainingMah = batteryPrefs.getFloat("remaining", BATTERY_FULL_CAPACITY_MAH);
  batteryPrefs.end();
  
  lastBatteryUpdate = millis();
  
  Serial.println("========================================");
  Serial.println("Battery Manager Initialized");
  Serial.print("Remaining: ");
  Serial.print(batteryRemainingMah, 2);
  Serial.print(" mAh (");
  Serial.print((int)((batteryRemainingMah / BATTERY_FULL_CAPACITY_MAH) * 100));
  Serial.println("%)");
  Serial.println("========================================");
}

void updateBatteryConsumption() {
  unsigned long currentTime = millis();
  unsigned long elapsedTime = currentTime - lastBatteryUpdate;
  
  if (elapsedTime < BATTERY_UPDATE_INTERVAL_MS) {
    return;
  }
  
  float elapsedHours = elapsedTime / 3600000.0;
  float consumedMah = BATTERY_AVERAGE_CURRENT_MA * elapsedHours;
  
  batteryRemainingMah -= consumedMah;
  if (batteryRemainingMah < 0) batteryRemainingMah = 0;
  
  if (!batteryPrefs.begin("battery", false)) {
    Serial.println("[ERROR] Failed to save battery to NVS!");
    return;
  }
  batteryPrefs.putFloat("remaining", batteryRemainingMah);
  batteryPrefs.end();
  
  lastBatteryUpdate = currentTime;
  
  Serial.print("[Battery] Consumed: ");
  Serial.print(consumedMah, 4);
  Serial.print(" mAh | Remaining: ");
  Serial.print(batteryRemainingMah, 2);
  Serial.print(" mAh (");
  Serial.print((int)((batteryRemainingMah / BATTERY_FULL_CAPACITY_MAH) * 100));
  Serial.println("%)");
  
  if (batteryRemainingMah <= BATTERY_CRITICAL_MAH) {
    Serial.println("[WARNING] CRITICAL BATTERY LEVEL!");
  } else if (batteryRemainingMah <= BATTERY_LOW_MAH && !lowBatteryWarningShown) {
    Serial.println("[WARNING] Low battery! Please charge soon.");
    lowBatteryWarningShown = true;
  }
}

void displayBatteryStatus(bool bluetoothConnected) {
  int batteryX = bluetoothConnected ? 88 : 108;
  int batteryY = 2;
  
  u8g2.drawFrame(batteryX, batteryY, 14, 8);
  u8g2.drawBox(batteryX + 14, batteryY + 2, 2, 4);
  
  int percentage = (int)((batteryRemainingMah / BATTERY_FULL_CAPACITY_MAH) * 100);
  int bars = 0;
  if (percentage > 66) bars = 3;
  else if (percentage > 33) bars = 2;
  else if (percentage > 0) bars = 1;
  else bars = 0;
  
  int barStartX = batteryX + 2;
  int barStartY = batteryY + 2;
  
  for (int i = 0; i < bars; i++) {
    int barX = barStartX + (i * 3);
    u8g2.drawBox(barX, barStartY, 2, 4);
  }
  
  if (batteryRemainingMah <= BATTERY_CRITICAL_MAH) {
    if ((millis() / 500) % 2 == 0) {
      u8g2.drawFrame(batteryX - 1, batteryY - 1, 16, 10);
      if (bars == 0) {
        u8g2.drawLine(batteryX + 6, batteryY + 2, batteryX + 6, batteryY + 4);
        u8g2.drawPixel(batteryX + 6, batteryY + 6);
      }
    }
  }
}

void handleBatteryReset() {
  bool buttonPressed = (digitalRead(BTN_CYCLE) == LOW);
  
  if (buttonPressed) {
    if (!batteryResetButtonPressed) {
      batteryResetPressStart = millis();
      batteryResetButtonPressed = true;
    } else {
      unsigned long holdDuration = millis() - batteryResetPressStart;
      
      if (holdDuration >= BATTERY_RESET_HOLD_TIME_MS) {
        batteryRemainingMah = BATTERY_FULL_CAPACITY_MAH;
        
        if (!batteryPrefs.begin("battery", false)) {
          Serial.println("[ERROR] Failed to reset battery in NVS!");
          return;
        }
        batteryPrefs.putFloat("remaining", batteryRemainingMah);
        batteryPrefs.end();
        
        lowBatteryWarningShown = false;
        batteryResetButtonPressed = false;
        
        u8g2.clearBuffer();
        u8g2.setFont(u8g2_font_helvB10_tr);
        const char* msg = "Battery Reset!";
        int msgX = (128 - u8g2.getStrWidth(msg)) / 2;
        u8g2.setCursor(msgX, 32);
        u8g2.print(msg);
        u8g2.sendBuffer();
        delay(1500);
        
        Serial.println("========================================");
        Serial.println("Battery Reset to Full Capacity");
        Serial.println("========================================");
        
        if (foundNetworks > 0) {
          showNetwork(currentIndex);
        }
      }
    }
  } else {
    batteryResetButtonPressed = false;
  }
}

void setup() {
  Serial.begin(115200);
  
  // Clear startup message
  Serial.println();
  Serial.println("========================================");
  Serial.println("ZYNC Device Starting Up...");
  Serial.println("========================================");
  
  pinMode(LED_PIN, OUTPUT);
  pinMode(BTN_CYCLE, INPUT_PULLUP);

  u8g2.begin();

  // Splash screen
  u8g2.clearBuffer();
  u8g2.drawBox(0, 0, 128, 64);
  u8g2.setDrawColor(0);
  u8g2.setFont(u8g2_font_logisoso32_tr);
  u8g2.setCursor((128 - u8g2.getStrWidth("ZYNC")) / 2, 48);
  u8g2.print("ZYNC");
  u8g2.sendBuffer();
  delay(2000);

  u8g2.setDrawColor(1);
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.setCursor((128 - u8g2.getStrWidth("Scanning...")) / 2, 32);
  u8g2.print("Scanning...");
  u8g2.sendBuffer();

  // Use AP+STA mode for better scanning capability
  WiFi.mode(WIFI_AP_STA);
    WiFi.softAP(ssid, password, 1, 0, 4); // channel 1, open, max 4 connections
    WiFi.softAPConfig(IPAddress(192,168,4,1), IPAddress(192,168,4,1), IPAddress(255,255,255,0));
    WiFi.softAPsetHostname("ZYNC_Device");
    WiFi.setSleep(false); // Disable WiFi sleep
    
    // Disconnect from any station connections to avoid interference
    WiFi.disconnect();

  // Print ESP32's MAC address for device identification
  Serial.println("=== ZYNC Device Information ===");
  Serial.print("Device MAC Address: ");
  Serial.println(WiFi.softAPmacAddress());
  Serial.print("WiFi AP IP Address: ");
  Serial.println(WiFi.softAPIP());
  Serial.println("================================");

  // Start TCP server for Live Scan with debugging
  Serial.println();
  Serial.println("Starting TCP server...");
  tcpServer.begin();
  Serial.println("TCP server started on port 8888");
  Serial.println("Waiting for app connections...");
  Serial.println();

  // Initialize Battery Management
  initBattery();

  // Initial scan and display first network
  scanNetworks();
  if (foundNetworks > 0) {
    currentIndex = 0;
    showNetwork(currentIndex);
  }
}

void loop() {
  // Check for WiFi station connections (phone connecting to ZYNC_Device)
  checkStationConnection();
  
  // Handle TCP connections and Live Scan
  handleTCPConnection();

  // Update battery consumption
  updateBatteryConsumption();
  
  // Handle battery reset via long button press
  handleBatteryReset();

  // Periodic TCP server status debug
  static unsigned long lastStatus = 0;
  if (millis() - lastStatus > 2000) { // every 2 seconds
    if (!client.connected()) {
      Serial.println("[DEBUG] TCP server running, waiting for client...");
    } else {
      Serial.println("[DEBUG] TCP server: client connected.");
    }
    lastStatus = millis();
  }

  // Handle button presses (but not while showing connection message)
  if (!showingConnectionMessage) {
    handleButton();
  }
  
  delay(50);
}

void checkStationConnection() {
  // Check if a device (phone) is connected to the ESP32 AP
  int numStations = WiFi.softAPgetStationNum();
  bool isConnected = (numStations > 0);
  
  // Detect new connection
  if (isConnected && !wasConnected) {
    Serial.println("========================================");
    Serial.println("Device connected to ZYNC_Device WiFi!");
    Serial.print("Number of connected devices: ");
    Serial.println(numStations);
    Serial.println("========================================");
    
    // Show 'CONNECTED!' on OLED
    showingConnectionMessage = true;
    connectionMessageTime = millis();
    
    u8g2.clearBuffer();
    
    // Draw a box background for emphasis
    u8g2.drawBox(0, 0, 128, 64);
    u8g2.setDrawColor(0); // Inverted colors (white text on black)
    
    // Draw checkmark circle (top center)
    u8g2.drawCircle(64, 22, 12); // Circle at center
    u8g2.drawCircle(64, 22, 11); // Double circle for emphasis
    
    // Draw checkmark inside circle
    u8g2.drawLine(58, 22, 61, 26); // Left part of check
    u8g2.drawLine(61, 26, 70, 18); // Right part of check
    u8g2.drawLine(58, 23, 61, 27); // Thicker check
    u8g2.drawLine(61, 27, 70, 19); // Thicker check
    
    // "CONNECTED!" text (smaller, readable size)
    u8g2.setFont(u8g2_font_helvB12_tr); // Medium bold font
    const char* msg = "CONNECTED!";
    int16_t x = (128 - u8g2.getStrWidth(msg)) / 2;
    int16_t y = 48; // Below the checkmark
    u8g2.setCursor(x, y);
    u8g2.print(msg);
    
    // Reset draw color back to normal (needed before drawing battery)
    u8g2.setDrawColor(1);
    
    // Display battery icon on connection screen
    displayBatteryStatus(true); // Bluetooth is connected
    
    u8g2.sendBuffer();
    
    wasConnected = true;
  }
  
  // Detect disconnection
  if (!isConnected && wasConnected) {
    Serial.println("Device disconnected from ZYNC_Device WiFi");
    wasConnected = false;
    showingConnectionMessage = false;
    
    // Return to network display
    if (foundNetworks > 0) {
      showNetwork(currentIndex);
    }
  }
  
  // Clear connection message after 2 seconds
  if (showingConnectionMessage && (millis() - connectionMessageTime > 2000)) {
    showingConnectionMessage = false;
    
    // Return to network display
    if (foundNetworks > 0) {
      showNetwork(currentIndex);
    }
  }
}

void handleTCPConnection() {
  // Check for new client connections
  if (!client.connected()) {
    if (client) {
      Serial.println("[DEBUG] Client disconnected from Live Scan.");
      client.stop();
      appConnected = false; // Mark app as disconnected
    }
    client = tcpServer.available();
    if (client) {
      Serial.println("========================================");
      Serial.println("App connected for Live Scan!");
      Serial.print("Client IP Address: ");
      Serial.println(client.remoteIP().toString());
      Serial.print("Client Port: ");
      Serial.println(client.remotePort());
      Serial.println("========================================");
      client.println("ZYNC_LIVE_SCAN_READY");
      appConnected = true; // Mark app as connected
      Serial.println("[DEBUG] appConnected set to TRUE");
      
      // Force display update to show Bluetooth icon
      if (foundNetworks > 0) {
        showNetwork(currentIndex);
      }
    }
    else {
      Serial.println("No client available for Live Scan.");
    }
    return;
  }
  
  // Handle incoming commands from app
  if (client.available()) {
    String command = client.readStringUntil('\n');
    command.trim();
    Serial.print("Received command: ");
    Serial.println(command);

    if (command == "START_LIVE_SCAN") {
      Serial.println("[DEBUG] START_LIVE_SCAN command received.");
      startLiveScan();
    } else if (command == "STOP_LIVE_SCAN") {
      Serial.println("[DEBUG] STOP_LIVE_SCAN command received.");
      stopLiveScan();
    } else if (command == "GET_BATTERY") {
      Serial.println("[DEBUG] GET_BATTERY command received.");
      sendBatteryStatus();
    } else {
      Serial.print("[DEBUG] Unknown command received: ");
      Serial.println(command);
    }
  }
  
  // Handle Live Scan data transmission
  if (liveScanActive && client.connected()) {
    if (millis() - lastLiveScan >= liveScanInterval) {
      Serial.println("[DEBUG] Performing live scan...");
      performLiveScan();
      lastLiveScan = millis();
    }
  }
  
  // Check if client is still connected and responsive
  if (client.connected()) {
    static unsigned long lastPing = 0;
    if (millis() - lastPing > 10000) { // Send ping every 10 seconds
      client.println("PING");
      lastPing = millis();
    }
  }
}

void startLiveScan() {
  liveScanActive = true;
  client.println("LIVE_SCAN_STARTED");
  Serial.println("Live Scan started");
  Serial.println("[DEBUG] liveScanActive set to true.");

  // Show Live Scan status on OLED
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.setCursor((128 - u8g2.getStrWidth("Live Scan Active")) / 2, 32);
  u8g2.print("Live Scan Active");
  
  // Display battery icon during live scan
  bool bluetoothConnected = (WiFi.softAPgetStationNum() > 0);
  displayBatteryStatus(bluetoothConnected);
  
  u8g2.sendBuffer();
}

void stopLiveScan() {
  liveScanActive = false;
  client.println("LIVE_SCAN_STOPPED");
  Serial.println("Live Scan stopped");
  Serial.println("[DEBUG] liveScanActive set to false.");

  // Return to normal display
  if (foundNetworks > 0) {
    showNetwork(currentIndex);
  }
}

void sendBatteryStatus() {
  int percentage = (int)((batteryRemainingMah / BATTERY_FULL_CAPACITY_MAH) * 100);
  String status = (batteryRemainingMah <= BATTERY_LOW_MAH) ? "LOW" : "OK";
  
  String response = "BATTERY:" + String(percentage) + ":" + 
                    String(batteryRemainingMah, 2) + ":" + status;
  client.println(response);
  
  Serial.print("Battery status sent: ");
  Serial.println(response);
}

void performLiveScan() {
  // Perform a quick scan for live data
  Serial.println("[DEBUG] Starting WiFi.scanDelete()");
  WiFi.scanDelete();
  Serial.println("[DEBUG] Starting WiFi.scanNetworks with all channels");
  // Scan all channels: async=true, show_hidden=true, passive=false, max_ms_per_chan=200 (faster for live scan)
  int scanResult = WiFi.scanNetworks(true, true, false, 200);

  if (scanResult == WIFI_SCAN_FAILED) {
    Serial.println("[DEBUG] WiFi.scanNetworks failed");
    client.println("LIVE_SCAN_ERROR:Scan failed");
    return;
  }

  // Wait for scan to complete (shorter timeout for live scan)
  unsigned long startTime = millis();
  while (WiFi.scanComplete() == WIFI_SCAN_RUNNING) {
    if (millis() - startTime > 3000) { // 3 second timeout for live scan
      Serial.println("[DEBUG] WiFi.scanComplete timeout");
      client.println("LIVE_SCAN_ERROR:Timeout");
      return;
    }
    delay(50);
  }

  int liveScanNetworks = WiFi.scanComplete();
  Serial.print("[DEBUG] WiFi.scanComplete result: ");
  Serial.println(liveScanNetworks);
  if (liveScanNetworks == WIFI_SCAN_FAILED) {
    Serial.println("[DEBUG] WiFi.scanComplete failed");
    client.println("LIVE_SCAN_ERROR:Scan failed");
    return;
  }

  // Send live scan data to app
  client.print("LIVE_DATA:");
  client.print(liveScanNetworks);
  client.print(":");

  for (int i = 0; i < liveScanNetworks && i < 20; i++) { // Limit to 20 networks
    client.print(WiFi.SSID(i));
    client.print(",");
    client.print(WiFi.BSSIDstr(i));
    client.print(",");
    client.print(WiFi.RSSI(i));
    client.print(",");
    client.print(WiFi.channel(i));
    client.print(",");
    client.print(translateEncryptionType(WiFi.encryptionType(i)));

    if (i < liveScanNetworks - 1 && i < 19) {
      client.print(";");
    }
  }
  client.println();

  Serial.print("Live scan sent: ");
  Serial.print(liveScanNetworks);
  Serial.println(" networks");
  Serial.println("[DEBUG] Live scan data sent to app.");
}

void scanNetworks() {
  // Show scanning message on screen
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.setCursor((128 - u8g2.getStrWidth("Scanning...")) / 2, 32);
  u8g2.print("Scanning...");
  u8g2.sendBuffer();
  
  // Start the scan with a timeout
  WiFi.scanDelete(); // Clear any previous scan
  
  // Scan ALL channels (1-13) with show_hidden=true to find all networks
  // Parameters: async=true, show_hidden=true, passive=false, max_ms_per_chan=300
  int scanResult = WiFi.scanNetworks(true, true, false, 300);
  
  if (scanResult == WIFI_SCAN_FAILED) {
    Serial.println("Scan failed to start");
    foundNetworks = 0;
    digitalWrite(LED_PIN, LOW);
    return;
  }
  
  // Wait for scan to complete with timeout and rapid LED blinking
  unsigned long startTime = millis();
  unsigned long lastBlinkTime = 0;
  bool ledState = false;
  
  while (WiFi.scanComplete() == WIFI_SCAN_RUNNING) {
    if (millis() - startTime > 10000) { // 10 second timeout
      Serial.println("Scan timeout");
      break;
    }
    
    // Rapid LED blinking during scan (every 100ms)
    if (millis() - lastBlinkTime >= 100) {
      ledState = !ledState;
      digitalWrite(LED_PIN, ledState ? HIGH : LOW);
      lastBlinkTime = millis();
    }
    
    delay(50); // Shorter delay for more responsive blinking
  }
  
  foundNetworks = WiFi.scanComplete();
  if (foundNetworks == WIFI_SCAN_FAILED) {
    Serial.println("Scan failed");
    foundNetworks = 0;
  }
  
  networks.clear();

  for (int i = 0; i < foundNetworks; i++) {
    NetworkInfo info;
    info.ssid = WiFi.SSID(i);
    info.bssid = WiFi.BSSIDstr(i);
    info.rssi = WiFi.RSSI(i);
    info.channel = WiFi.channel(i);
    info.frequency = 2407 + (info.channel * 5);
    info.encryption = translateEncryptionType(WiFi.encryptionType(i));
    networks.push_back(info);
  }

  // Turn off LED when scan is complete
  digitalWrite(LED_PIN, LOW);
  
  Serial.print("Scan complete. Found: ");
  Serial.println(foundNetworks);
}

void showScanningAnimation() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_10x20_tr); // Bigger font
  
  // Create animated dots
  String dots = "";
  for (int i = 0; i < scanDots; i++) {
    dots += ".";
  }
  
  String scanningText = "Scanning" + dots;
  
  // Center the text
  int textWidth = u8g2.getStrWidth(scanningText.c_str());
  int x = (128 - textWidth) / 2;
  int y = 32;
  
  u8g2.setCursor(x, y);
  u8g2.print(scanningText);
  u8g2.sendBuffer();
}

String translateEncryptionType(wifi_auth_mode_t type) {
  switch (type) {
    case WIFI_AUTH_OPEN: return "Open";
    case WIFI_AUTH_WEP: return "WEP";
    case WIFI_AUTH_WPA_PSK: return "WPA";
    case WIFI_AUTH_WPA2_PSK: return "WPA2";
    case WIFI_AUTH_WPA_WPA2_PSK: return "WPA/WPA2";
    case WIFI_AUTH_WPA2_ENTERPRISE: return "Enterprise";
    case WIFI_AUTH_WPA3_PSK: return "WPA3";
    case WIFI_AUTH_WPA2_WPA3_PSK: return "WPA2/WPA3";
    case WIFI_AUTH_WPA3_ENTERPRISE: return "WPA3-Enterprise";
    default: return "Unknown";
  }
}

void showNetwork(int index) {
  if (networks.empty()) return;
  u8g2.clearBuffer();
  
  NetworkInfo net = networks[index];
  
  // Calculate user-friendly metrics
  String safetyLevel = getSafetyLevel(net.encryption);
  String signalQuality = getSignalQuality(net.rssi);
  String simpleSecurity = getSimpleSecurity(net.encryption);
  String riskLevel = getRiskLevel(net.encryption);
  
  // === OPTIMIZED DISPLAY LAYOUT ===
  
  // Battery and Bluetooth Icons (Top Right)
  int numStations = WiFi.softAPgetStationNum();
  bool bluetoothConnected = (numStations > 0);
  
  // Display battery icon (positioned based on Bluetooth status)
  displayBatteryStatus(bluetoothConnected);
  
  // Display Bluetooth icon if connected
  if (bluetoothConnected) {
    drawBluetoothIcon(110, 2);
  }
  
  // Network Name (Top Left, Bold)
  u8g2.setFont(u8g2_font_helvB08_tr); // Bold font
  String displaySSID = net.ssid;
  if (displaySSID.length() > 12) {
    displaySSID = displaySSID.substring(0, 9) + "...";
  }
  u8g2.setCursor(2, 10);
  u8g2.print(displaySSID);
  
  // Divider line
  u8g2.drawHLine(0, 12, 128);
  
  // Safety Status (Large, Centered, NO ICON)
  u8g2.setFont(u8g2_font_helvB12_tr); // Even bigger bold font
  int safetyX = (128 - u8g2.getStrWidth(safetyLevel.c_str())) / 2;
  u8g2.setCursor(safetyX, 28);
  u8g2.print(safetyLevel);
  
  // Signal Strength Bar (Horizontal progress bar)
  int barWidth = 100; // Total bar width
  int barHeight = 6;  // Bar height
  int barX = (128 - barWidth) / 2; // Center the bar
  int barY = 32;
  
  // Draw outline
  u8g2.drawFrame(barX, barY, barWidth, barHeight);
  
  // Calculate fill based on RSSI
  int fillWidth = getSignalBarWidth(net.rssi, barWidth - 4); // -4 for padding
  if (fillWidth > 0) {
    u8g2.drawBox(barX + 2, barY + 2, fillWidth, barHeight - 4);
  }
  
  // Signal Strength - BOLD BARS (Centered)
  u8g2.setFont(u8g2_font_helvB10_tr); // Bold font for bars
  String signalBars = getSignalBars(net.rssi);
  int barsX = (128 - u8g2.getStrWidth(signalBars.c_str())) / 2;
  u8g2.setCursor(barsX, 48);
  u8g2.print(signalBars);
  
  // Signal Quality Text (Below bars, Centered, Smaller)
  u8g2.setFont(u8g2_font_6x10_tr); // Normal font
  int qualityX = (128 - u8g2.getStrWidth(signalQuality.c_str())) / 2;
  u8g2.setCursor(qualityX, 52);
  u8g2.print(signalQuality);
  
  // Bottom Row: Security and Risk (Side by side)
  u8g2.setFont(u8g2_font_5x7_tr); // Smaller font for bottom info
  
  // Display only the encryption type
  String secText = simpleSecurity;
  u8g2.setCursor(0, 62);
  u8g2.print(secText);
  
  // Risk on the right side (only if there's enough space)
  int minSpace = 30; // Minimum pixels needed for risk text
  if (128 - u8g2.getStrWidth(secText.c_str()) > minSpace) {
    String riskText = "Risk: " + riskLevel;
    int riskX = 128 - u8g2.getStrWidth(riskText.c_str());
    u8g2.setCursor(riskX, 62);
    u8g2.print(riskText);
  }
  
  u8g2.sendBuffer();
}

// === BLUETOOTH ICON FUNCTION ===

void drawBluetoothIcon(int x, int y) {
  // Simple Bluetooth icon using lines (6x6 pixels - even smaller)
  // Vertical line
  u8g2.drawLine(x + 3, y, x + 3, y + 6);
  
  // Top triangle
  u8g2.drawLine(x + 3, y, x + 5, y + 2);
  u8g2.drawLine(x + 5, y + 2, x + 3, y + 3);
  
  // Bottom triangle
  u8g2.drawLine(x + 3, y + 3, x + 5, y + 4);
  u8g2.drawLine(x + 5, y + 4, x + 3, y + 6);
  
  // Cross lines
  u8g2.drawLine(x + 1, y + 2, x + 5, y + 4);
  u8g2.drawLine(x + 1, y + 4, x + 5, y + 2);
}

// === HELPER FUNCTIONS FOR USER-FRIENDLY DISPLAY ===

String getSafetyLevel(String encryption) {
  if (encryption == "Open") return "UNSAFE";
  if (encryption == "WEP") return "RISKY";
  if (encryption == "WPA") return "OKAY";
  if (encryption == "WPA2" || encryption == "WPA/WPA2") return "SAFE TO USE";
  if (encryption == "WPA3" || encryption == "WPA2/WPA3") return "VERY SAFE";
  if (encryption == "Enterprise" || encryption == "WPA3-Enterprise") return "VERY SAFE";
  return "UNKNOWN";
}

String getSafetyIcon(String encryption) {
  // Using simple ASCII characters that display well on OLED
  if (encryption == "Open") return "[!]"; // Warning
  if (encryption == "WEP") return "[~]"; // Caution
  if (encryption == "WPA") return "[+]"; // Okay
  if (encryption == "WPA2" || encryption == "WPA/WPA2") return "[*]"; // Good
  if (encryption == "WPA3" || encryption == "WPA2/WPA3") return "[**]"; // Excellent
  if (encryption == "Enterprise" || encryption == "WPA3-Enterprise") return "[**]"; // Excellent
  return "[?]";
}

String getSignalQuality(int rssi) {
  if (rssi >= -50) return "Excellent";
  if (rssi >= -60) return "Good";
  if (rssi >= -70) return "Fair";
  if (rssi >= -80) return "Weak";
  return "Very Weak";
}

String getSignalBars(int rssi) {
  // Visual signal strength with bold block characters
  if (rssi >= -50) return "█████"; // 5 bars - Excellent
  if (rssi >= -60) return "████▒"; // 4 bars - Good
  if (rssi >= -70) return "███▒▒"; // 3 bars - Fair
  if (rssi >= -80) return "██▒▒▒"; // 2 bars - Weak
  return "█▒▒▒▒"; // 1 bar - Very Weak
}

int getSignalBarWidth(int rssi, int maxWidth) {
  // Convert RSSI to percentage for horizontal bar
  // RSSI range: -100 (worst) to -30 (best)
  int percentage;
  
  if (rssi >= -50) {
    percentage = 100; // Excellent
  } else if (rssi >= -60) {
    percentage = 80; // Good
  } else if (rssi >= -70) {
    percentage = 60; // Fair
  } else if (rssi >= -80) {
    percentage = 40; // Weak
  } else if (rssi >= -90) {
    percentage = 20; // Very Weak
  } else {
    percentage = 10; // Extremely Weak
  }
  
  return (maxWidth * percentage) / 100;
}

String getSimpleSecurity(String encryption) {
  if (encryption == "Open") return "None";
  if (encryption == "WEP") return "Weak";
  if (encryption == "WPA") return "Basic";
  if (encryption == "WPA2" || encryption == "WPA/WPA2") return "Protected";
  if (encryption == "WPA3" || encryption == "WPA2/WPA3") return "Strong";
  if (encryption == "Enterprise" || encryption == "WPA3-Enterprise") return "Maximum";
  return "Unknown";
}

String getRiskLevel(String encryption) {
  if (encryption == "Open") return "High";
  if (encryption == "WEP") return "Medium";
  if (encryption == "WPA") return "Medium";
  if (encryption == "WPA2" || encryption == "WPA/WPA2") return "Low";
  if (encryption == "WPA3" || encryption == "WPA2/WPA3") return "Very Low";
  if (encryption == "Enterprise" || encryption == "WPA3-Enterprise") return "Very Low";
  return "Unknown";
}

void handleButton() {
  // Check if enough time has passed since last button press
  if (millis() - lastButtonTime < debounceDelay) return;

  // Check if button is pressed (LOW because of INPUT_PULLUP)
  if (digitalRead(BTN_CYCLE) == LOW) {
    Serial.println("Button pressed!"); // Debug output
    
    // Do a fresh scan
    scanNetworks();
    
    // Small delay to ensure scan completes
    delay(100);
    
    // Then cycle to next network (if we have networks)
    if (foundNetworks > 0) {
      // White background flash
      u8g2.clearBuffer();
      u8g2.setDrawColor(0);
      u8g2.drawBox(0, 0, 128, 64);
      u8g2.sendBuffer();
      delay(30);
      u8g2.setDrawColor(1);
      
      // Cycle to next network
      currentIndex = (currentIndex + 1) % foundNetworks;
      Serial.print("Switching to network: "); // Debug output
      Serial.println(currentIndex);
      
      showNetwork(currentIndex);
    }
    
    // Update button time
    lastButtonTime = millis();
  }
}
